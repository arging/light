// Copyright 2014 li. All rights reserved.

package db

import (
	"bytes"
	"github.com/roverli/light/log"
	"reflect"
	"strconv"
	"strings"
)

type SQLResutMap struct {
	id         string
	structName string
	properties []*SQLResultProperty
}

type SQLActionCmd struct {
	operation    Operation
	id           string
	resultMap    string
	resultStruct string
	sql          string
	dynamicer    string
}

type SQLResultProperty struct {
	property string
	column   string
	goType   string
	nilValue string
}

type Statement struct {
	id string // Unique identifier

	/*----Field For Debug Log---*/
	sql           string   // Origin sql string
	stdSQL        string   // Standard sql string, convert from sql field
	params        []string // Sql param names, extract from sql field
	dynamicerName string   // Dynamicer Name
	/*-------------------------*/

	op         Operation  // The operation cmd type: SELECT/UPDATE/INSERT/DELETE/UNKNOW
	dynamicer  Dynamicer  // StdSQL and Params is generated by Dynamicer every time.
	rProcessor RProcessor // For proc result.
	pProcessor PProcessor // For proc params.
}

// For Log
func (s *Statement) String() string {
	buf := bytes.NewBufferString("[\n")
	buf.WriteString("Statement ID:" + s.id + "\n")
	buf.WriteString("SQL:" + s.sql + "\n")
	buf.WriteString("StdSQL:" + s.stdSQL + "\n")
	buf.WriteString("Params:{" + strings.Join(s.params, ",") + "} ]\n")

	return buf.String()
}

func (s *Statement) ProcParam(v interface{}) (string, []interface{}) {
	if s.dynamicer != nil {
		return s.dynamicer(v)
	}
	return s.pProcessor.Proc(v)
}

func (s *Statement) HoldValue(columns []string) (reflect.Value, []interface{}) {
	return s.rProcessor.GetValueHolder(columns)
}

func (s *Statement) ToValue(source reflect.Value) interface{} {
	return s.rProcessor.ToValue(source)
}

func initStatements(db *DB, actionCmds map[string]*SQLActionCmd,
	actionResultMaps map[string]*SQLResutMap) {
	for _, cmd := range actionCmds {

		statement := &Statement{id: cmd.id,
			sql:           cmd.sql,
			op:            cmd.operation,
			dynamicerName: cmd.dynamicer,
		}

		// Params | Dynamicer wins ParamStruct, ParamStruct wins ParamMap.
		switch {
		case cmd.dynamicer != "":
			dynamicer := db.dynamicers[cmd.dynamicer]
			panicfIfNil(dynamicer, "dynamicer %s not found.", cmd.dynamicer)
			statement.dynamicer = dynamicer

		case cmd.dynamicer == "":
			stdSQL, params, err := toStandardSQL(cmd.sql)
			panicfIfErr(err, "Invalid SQL: %s. Statement: %s.", cmd.sql, cmd.id)

			statement.stdSQL = stdSQL
			statement.params = params

			statement.pProcessor = &StdPProcessor{
				stdSQL: stdSQL,
				params: params,
			}
		}

		// Struct wins reslutMap
		switch {
		case cmd.resultStruct != "":
			switch typ, ok := goTypeMapping[cmd.resultStruct]; ok {
			case true:
				statement.rProcessor = &OneColumnProcessor{typ: typ, id: cmd.id}
			// case "time": Not suppoted
			default:
				v := db.types[cmd.resultStruct]
				r := parseStructResult(cmd.id, v, true)
				statement.rProcessor = &RSProcessor{
					SQLStructResult: r,
					id:              cmd.id}
			}

		case cmd.resultMap != "":
			rmap := actionResultMaps[cmd.resultMap]
			panicfIfNil(rmap, "Invalid resultmap: %s.", cmd.resultMap)

			v := db.types[rmap.structName]
			r := parseStructResult(cmd.id, v, false)

			columnMapping := make(map[string]FieldIndex)
			for _, prop := range rmap.properties {

				fIndex := columnMapping[prop.property]
				panicfIfNil(fIndex, "No field %s found in struct %s", prop.property, rmap.structName)
				columnMapping[prop.column] = fIndex

				if prop.nilValue == "" || prop.goType == "" {
					continue
				}

				switch prop.goType {
				case "int":
					intV, err := strconv.Atoi(prop.nilValue)
					panicfIfErr(err, "Cann't convert %s to int for resultMap %s", prop.nilValue, rmap.id)
					fIndex.hasNilValue = true
					fIndex.value = intV

				case "string":
					fIndex.hasNilValue = true
					fIndex.value = prop.nilValue
				}
			}

			statement.rProcessor = &RMProcessor{
				SQLStructResult: r,
				columnMapping:   columnMapping,
				id:              cmd.id}

		}

		db.statements[statement.id] = statement
		log.Debugf("light/db: Init Statement: %s", statement)
	}
}

func parseStructResult(id /*For Log*/ string, i interface{}, multiKey bool) *SQLStructResult {
	r := &SQLStructResult{}
	t := reflect.TypeOf(i)
	if t.Kind() == reflect.Ptr {
		r.isPtr = true
		t = t.Elem()
	}

	r.typ = t
	panicfIfTrue(t.Kind() != reflect.Struct, "Param not struct. Kind: %v. Statment:%s.", t.Kind(), id)

	// Supported for nested struct.
	indexMap := make(map[string]FieldIndex)
	for i := 0; i < t.NumField(); i++ {
		parseStructResult1(t.Field(i), indexMap, []int{i}, multiKey)
	}
	r.indexes = indexMap

	return r
}

func parseStructResult1(field reflect.StructField,
	indexMap map[string]FieldIndex, index []int, multiKey bool) {
	if !isExportedField(field.Name) {
		return
	}

	t := field.Type
	if t.Kind() == reflect.Struct && t != TimeType {
		for i, num := 0, t.NumField(); i < num; i++ {
			parseStructResult1(t.Field(i), indexMap, append(index, i), multiKey)
		}
	}

	fIndex := FieldIndex{index: index, typ: t}
	indexMap[field.Name] = fIndex
	if multiKey {
		indexMap[strings.ToLower(field.Name)] = fIndex
		indexMap[toUnderLineCase(field.Name)] = fIndex
	}
}
